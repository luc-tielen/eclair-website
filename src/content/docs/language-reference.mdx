---
title: Language reference
---

import CodeBlock from "../../components/CodeBlock.tsx";

This page contains an overview of all the current features in Eclair and their
corresponding syntax.

## Declarations

A program consists of zero or more top-level declarations.
Declarations can be [type definitions](#type-definitions), [atoms](#atoms),
[rules](#rules) or [extern definitions](#extern-definitions).
Together, they can be used to describe logical queries that Eclair will search
for in a given dataset.

Syntactically, a period (`.`) is used to mark the end of each declaration.

### Type definitions

Before you can use a _relation_ in a [atom](#atoms) or [rule](#rules), you
will first need to declare them. A type definition consists of the name of the
relation, along with the [types](#primitive-types) of each of their arguments.
Note that a relation requires always at least one argument.

Besides the name of the relation and its arguments, you can also specify if the
relation is meant to be used as an `input`, `output`, as both `input` and
`output`.

**Important**: If you do not add any usage qualifier, Eclair will assume the
relation is only used internally. If you then try to add data or retrieve
results from an internal relation, Eclair will do _nothing_ (because no code for
this functionality would have been generated).

Below are some example type definitions:

<CodeBlock
  language="eclair"
  code={`
@def input_example(arg1: u32) input.
@def output_example(arg1: string, arg2: u32) output.
@def input_output(arg1: string) input output.
@def internal_relation(arg1: string).
`}
/>

### Atoms

Once a relation is defined, it can be used as an _atom_. Atoms can appear
either directly as a top-level declaration, or inside a [rule](#rules).
A top-level atom is also referred to as _fact_. When an atom is used inside the
body of a rule, they are referred to as a _(rule) clause_.

An atom consists of the name of the relation, followed by one or more arguments.
Note that for top-level atoms, it is only allowed to use constant literals for
one of the arguments; [variables](#variables) or [wildcards](#wildcards) are
not allowed. The snippet below shows examples of some facts:

<CodeBlock language="eclair" code={
`
@def person(first_name: string, last_name: string, age: u32).
@def siblings(first_sibling: string, second_sibling: string).

person("John", "Doe", 30).
person("Jane", "Doe", 27).

siblings("John", "Jane").
`
} />

In the next section about [rules](#rules), more examples will be given how to
use atoms inside rule bodies.

Besides facts defined directly in Eclair code, it is also possible to use the
[Eclair API](/docs/api) to insert _input_ facts or retrieve _output_ facts dynamically.

### Rules

Besides atoms, relations can also be used in rules.

TODO what does rule consist of, recursive rules, joins (and), disjunction, explain negation (link to negation doc)

The following code snippet shows how you can use rules to find all reachable vertices in a graph:

<CodeBlock language="eclair" code={
`
@def edge(from: u32, to: u32) input.
@def reachable(start: u32, end: u32) output.

reachable(x, y) :-
edge(x, y).

reachable(x, y) :-
edge(x, z),
reachable(z, y).
`
} />

### Extern definitions

## Primitive types

Eclair currently has support for the 32-bit [unsigned integers](#integers) and
[string](#strings) primitive types. Other types such as signed integers are
planned and will be added in the future.

### Integers

Integer literals should be written down in decimal form. Integer arguments in
[type definitions](#type-definitions) are specified with the `u32` keyword.
The following snippet shows the syntax for using integers:

<CodeBlock
  language="eclair"
  code={`
@def coordinate(x: u32, y: u32).

coordinate(3, 7).
coordinate(8, 4).
`}
/>

Integers can be used in both [arithmetic expressions](#arithmetic) or
[comparisons](#comparisons).

### Strings

String literals in Eclair start and end with a double-quote (`"`) and can
contain zero or more characters. String arguments in [type
definitions](#type-definitions) are specified with the `string` keyword. The
code below is a small example of how you can use string literals:

<CodeBlock language="eclair" code={
`
@def book(title: string).

book("Structure and Interpretation of Computer Programs").
book("7 languages in 7 weeks").
`
} />

Internally, strings are stored as UTF-8-encoded bytearrays with a known length.
They do not have a 0-terminator like in C.

Eclair only provides very minimal functionality for strings in the form of
[(in-)equality comparisons](#comparisons). This is done to keep the language
small. If you do need extra functionality (e.g. regex support), you can add
this functionality with [user-defined functions](/docs/user-defined-functions).

## Variables

TODO mention [grounding](/docs/grounding)

### Wildcards

Wildcards are a special kind of variable that you can use in Eclair when you
_don't care_ about a specific argument value in a rule clause. A wildcard
variable unifies with every value. The syntax for a wildcard is a single
underscore (`_`). The code below shows how you could use wildcards to ignore
some arguments in a fact:

<CodeBlock language="eclair" code={
`
@def person(name: string, age: u32).
@def person_name(name: string).

person*name(name) :-
person(name, *).
`
} />

Unlike variables, if there are more than two wildcards in a rule body, they
will **not** unify with each other. In other words, each wildcard is treated as
a unique variable. The following example shows how the compiler would rewrite a
rule containing multiple wildcards:

<CodeBlock language="eclair" code={
`
rule(x) :-
  fact1(x, _),
  fact2(x, y, _).

// will be rewritten as:

rule(x) :-
fact1(x, wildcard_var1),
fact2(x, y, wildcard_var2).
`
} />

Wildcards are not allowed in rule heads or in arithmetic expressions; they are
only allowed as arguments of rule clauses. This restriction is necessary to
make sure the program can be properly compiled.

### Typed holes

Typed holes (also referred to as just _holes_) represent a piece of Eclair code
that is _unfinished_. They make it possible to have a valid Eclair program that
is not fully thought out yet, but that the compiler can still reason about.

Holes are allowed in any location in a rule body where expressions (literal
values or variables) are allowed. The syntax for a typed hole is a single
question mark (`?`).

<CodeBlock language="eclair" code={
`
reachable(x, y) :-
 edge(x, ?),
 reachable(z, y).

fact(?).

rule(x) :-
x = ?,
fact(x).
`
} />

When you use a typed hole, you can ask the Eclair compiler to show you the
type-level information that it deduced at that location in the program. This
can be useful to help figuring out type errors in your program. For more
information about typed holes, check out the
[typesystem documentation](/docs/typesystem).

## Operators

Eclair provides built-in operators for doing [arithmetic](#arithmetic) or
[comparing values](#comparisons). The following sections provide more
information on where these operators are allowed and how they can be used.

### Comparisons

Eclair supports built-in operators for comparing 2 values. These can be divided
into equality constraints (`=` and `!=`), and inequality comparisons (`<`,
`<=`, `>` and `>=`). Equality constraints are supported on all types. The
comparison operators are supported only on integer values.

**Important**: the equality operator has different behavior compared to most
other languages! In Eclair, equality is actual mathematical equality; it is
_not_ an assignment of a variable. This means that when you write `x = 3`, you
are saying that `x` equals to `3`. (On a side note, this means you can also
write `3 = x`.) Besides this, the equality operator also plays an important
rule in [grounding variables](/docs/grounding).

The code below shows how comparisons can be used in Eclair.

<CodeBlock
  language="eclair"
  code={`
rule(x) :-
  fact(x),
  x < 10,
  x >= 3,
  x != 7.
`}
/>

Comparison operators can only appear in a rule body. Only one comparison is
possible per clause, compound in-equality comparisons are not supported.

### Arithmetic

Eclair supports arithmetic operators found in most other languages. For now
the supported operators are `+`, `-`, `*`, and `/`. In the future more
operators will be added (bitwise operators, logical operators, ...).

Operators can be used in any rule clause and even in the rule head, as long as
both arguments of the binary operation are [grounded](/docs/grounding).

Expressions with arithmetic operators can be nested, and have the same
precedence rules as in math. Parentheses can be used to override the order
in which sub-expressions are evaluated.

The snippet below showcases how you can use arithmetic operators:

<CodeBlock
  language="eclair"
  code={`
rule(x + y) :-
  fact1(x),
  fact2(y + 5 * 7),
  y = (1 + 8) / 3 * 4.
`}
/>

Arithmetic operations are only supported on integers. If you want to do e.g.
string concatenation (commonly done with `+` in other languages), then you will
need to create a [user-defined function](#user-defined-functions) that
implements this behavior.

## Comments

Comments in Eclair have the same syntax as C-style languages. They can appear
anywhere in the code. Single-line comments are prefixed with `//` and continue
until the end of the current line. Multi-line comments start with `/*` and end
with `*/` and can span multiple lines. Below is a snippet of Eclair code with
some comments:

<CodeBlock language="eclair" code={
`
// A single line comment

/_
A comment
spanning
multiple lines.
_/
`
} />
